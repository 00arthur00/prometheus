// {
//   set evaluation_interval = "30s";
//   target "http://www.example.com:80/metrics"

//   rule archived {name="instance:requests_total:sum"} = sum by (instance) {name="requests"};
//   rule archived {name="instance:requests-by_result_code_total:sum"} =
//       sum by (instance,result_code) {name="requests"};
//   rule archived {name="instance:requests-by_result_code:sum"} =
//       {name="instances:requests-by_result_code"}
//         / by (instance)
//       {name="instances:requests_total:sum"};
// }

{
  set evaluation_interval = “2m”;

  permanent {
    rule {
      labels {
        set name = “process:request_rate_qps-allowed:sum”;
        set job = “frontend”;
      }

      // Values may be a literal or an expression.
      set value = 500;

      // I wonder: Is it practical to express labels similar to above in a better DSL?
      // set value = EXPRESSION … WITH LABELS {foo=”bar”};
    }
  }

    rule {
      // This provides a way of overriding existing labels, unsetting them, or
      // appending new ones.
      labels {
        // “name” is obligatory.
        set name = “process:requests_total:sum”;
      }

      // Here we are extracting a metric with the name label value of “requests” from
      // job “frontend” and merely accumulating this into a named variable.  It is
      // similar to standing.  Each sum is keyed to the UNIX process and job from which
      // it came.
      set value = SUM({name=”requests”, job=”frontend”}) BY (process, job);
    }

    rule {
      // This provides a way of overriding existing labels, unsetting them, or
      // appending new ones.
      labels {
        // “name” is obligatory.
        set name = “process:request_qps:rate5m”;
      }

      // Here we are extracting a metric with the name label value of “requests” from
      // job “frontend” and merely accumulating this into a named variable.  It is
      // similar to standing.
      set value = RATE({name=”process:requests_total:sum”, job=”frontend”} OVER “5m”);
    }
  }
}