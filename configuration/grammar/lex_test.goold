package main

import (
	"testing"
)

type lexTest struct {
	name     string
	input    string
	elements []element
}

var (
	tEof          = element{itemEof, ""}
	tOpenRuleset  = element{itemOpenBracket, "{"}
	tCloseBracket = element{itemCloseBracket, "}"}
	tIllegal      = element{itemError, "illegal input"}
	tSet          = element{itemSetKeyword, "set"}
	tEqual        = element{itemEqual, "="}
	tQuote        = element{itemQuote, `"`}
	tSemicolon    = element{itemSemicolon, ";"}
	tRules        = element{itemRulesKeyword, "rules"}
)

var lexTests = []lexTest{
	{
		"empty",
		"",
		[]element{
			tEof,
		},
	},
	{
		"empty with new line",
		"\n\n",
		[]element{
			tEof,
		},
	},
	{
		"one empty ruleset",
		"{}",
		[]element{
			tOpenRuleset,
			tCloseBracket,
			tEof,
		},
	},
	{
		"one empty ruleset distributed over new line",
		"{\n}",
		[]element{
			tOpenRuleset,
			tCloseBracket,
			tEof,
		},
	},
	{
		"two empty rulesets",
		"{} {}",
		[]element{
			tOpenRuleset,
			tCloseBracket,
			tOpenRuleset,
			tCloseBracket,
			tEof,
		},
	},
	{
		"two empty rulesets distributed over new line",
		"{}\n{}",
		[]element{
			tOpenRuleset,
			tCloseBracket,
			tOpenRuleset,
			tCloseBracket,
			tEof,
		},
	},
	{
		"garbage",
		"garbage",
		[]element{tIllegal},
	},
	{
		"one set",
		`{ set foo = "bar"; }`,
		[]element{
			tOpenRuleset,
			tSet,
			element{itemKey, "foo"},
			tEqual,
			tQuote,
			element{itemValue, "bar"},
			tQuote,
			tSemicolon,
			tCloseBracket,
			tEof,
		},
	},
	{
		"one set over multiple lines",
		`{
		 set
		 foo
		 =
		 "bar"
		 ;
		 }`,
		[]element{tOpenRuleset, tSet, element{itemKey, "foo"}, tEqual, tQuote, element{itemValue, "bar"}, tQuote, tSemicolon, tCloseBracket, tEof},
	},
	{
		"two sets",
		`{ set foo = "bar";set baz = "qux"; }`,
		[]element{
			tOpenRuleset,
			tSet,
			element{itemKey, "foo"},
			tEqual,
			tQuote,
			element{itemValue, "bar"},
			tQuote,
			tSemicolon,
			tSet,
			element{itemKey, "baz"},
			tEqual,
			tQuote,
			element{itemValue, "qux"},
			tQuote,
			tSemicolon,
			tCloseBracket,
			tEof,
		},
	},
	{
		"two over multiple lines",
		`{ set foo = "bar";
		 set
baz
=
"qux"
;
}`,
		[]element{
			tOpenRuleset,
			tSet,
			element{itemKey, "foo"},
			tEqual,
			tQuote,
			element{itemValue, "bar"},
			tQuote,
			tSemicolon,
			tSet,
			element{itemKey, "baz"},
			tEqual,
			tQuote,
			element{itemValue, "qux"},
			tQuote,
			tSemicolon,
			tCloseBracket,
			tEof,
		},
	},
}

func collect(l *lexTest) []element {
	_, v := lex("", l.input)

	emission := make([]element, 0)

	for i := range v {
		emission = append(emission, i)
	}

	return emission
}

func TestFoo(t *testing.T) {
	for _, test := range lexTests {
		e := collect(&test)

		if len(e) != len(test.elements) {
			t.Errorf("%s: got\n\n\t%v\nexpected\n\n\t%v", test.name, e, test.elements)
		}

		for i, _ := range test.elements {
			if test.elements[i] != e[i] {
				t.Errorf("%s[%d]: got\n\n\t%v\nexpected\n\n\t%v", test.name, i, e[i], test.elements[i])
			}
		}
	}
}
